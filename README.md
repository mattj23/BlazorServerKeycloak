# Blazor Server Keycloak Integration
Razor class library to add OIDC authentication to a Blazor server-side application

## Motivation

Blazor's server-side hosting model is extremely quick and convenient to develop with, and is more than adequate for internal line-of-business type applications which, by nature, have relatively few simultaneous users.  

Keycloak is an OpenIDConnect provider that is especially useful for internal applications because it can federate with LDAP (and Active Directory in particular) and effectively offer authentication against it through OIDC, even going so far as to map AD security groups as realm roles which are available as claims in the client application.

Nominally, the combination of server-side Blazor authenticated against Keycloak would be an ideal platform for rapidly developing and deploying internal business applications while hooking into existing centralized identity and access management tools common in small business infrastructure.  However, with the server-side hosting model the use of the SignalR hub and the lack of an `HttpContext` in established connections means that typical authentication schemes are not straightforward to implement.

This is a Razor class library which borrows heavily from https://github.com/vip32/aspnetcore-keycloak and packages all of the necessary components for authentication against Keycloak using OpenID Connect, including the configuration, the sign-in and sign-out endpoints, and an authorization requirement and handler to map to imported realm roles.

## Installation

The BlazorServerKeycloak library can be added to an .NET 6+ application either as a Nuget package or via git using the submodule mechanism.  The library was designed for and tested with server-side Blazor projects, I do not know if it will work with other types of ASP.NET projects, and I do not believe there is any reason to use it in such cases where a `HttpContext` is available for cookie based authentication.

### Nuget Package
Todo: Nuget package

### Git submodule

In your project, add this repo as a submodule.

In your solution file, add the existing project `BlazorServerKeycloak.csproj`.  Then in your Blazor server-side project's dependencies add a project reference to `BlazorServerKeycloak`.

## Project Setup

To establish authentication via OIDC through Keycloak, you will need a Keycloak instance with a configured client for your application. If you do not have a client configured already and need help setting it up, refer to the [Preparing Keycloak](#preparing-keycloak) section below.


### Application Settings

You will need a section in your application configuration for the OIDC provider.

```json
"Oidc": {
    "Authority": "https://<keycloak url>/auth/realms/<realm name>",
    "ClientId": "<client id>",
    "ClientSecret": "<client secret>",
    "Resource": "<client id>",
    "Scope": [ "roles" ],
    "ResponseType": "code",
    "GetClaimsFromUserInfoEndpoint": false,
    "SaveTokens": true
}
```

Here the `Authority` is the URL of the Keycloak realm the application client was created under.  The `ClientId` is the id created for the client in Keycloak, and the `ClientSecret` is the token generated by Keycloak to match the client id.  Refer to the [Preparing Keycloak](#preparing-keycloak) section for more information.

### Program startup

In the new, simplified ASP.NET 6.0 setup's `Program.cs` file you will need to both add Keycloak integration to the `builder`'s service collection before the application is built and add authentication/authorization to the application.

```c#
var builder = WebApplication.CreateBuilder(args);

// The Http context accessor is needed for the system to work, make sure to add it if you don't have it already
builder.Services.AddHttpContextAccessor();

// Place this somewhere before the call to AddRazorComponents.
builder.Services.AddKeycloakAuthentication(builder.Configuration.GetSection("Oidc"));
// [..]
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

```

For ASP.NET Core 7 and earlier:

```c#
// [...]
app.UseStaticFiles();
app.UseRouting();

// Insert UseAuthentication and UseAuthorization in this order
app.UseAuthentication();
app.UseAuthorization();

// [...]
app.MapBlazorHub();
app.MapFallbackToPage("/_Host");
app.MapAuthEndpoints();
app.Run();
```

For ASP.NET Core 8:

```c#
// [...]
app.UseStaticFiles();

// Insert UseAuthentication and UseAuthorization in this order
app.UseAuthentication();
app.UseAuthorization();

// Antiforgery needs to go after the calls to UseAuthentication and UseAuthorization
app.UseAntiforgery();    

app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();

app.MapAuthEndpoints();
app.Run();

```

### Imports and App.Razor

This library contains two razor components to help with the login process, located in the namespace `BlazorServerKeycloak.Components.Shared`.  If you intend to use them you will need to add `@using` directives to any razor components which will reference them, or add them globally to the end of your project's `_Imports.razor` as shown:

```razor
@using BlazorServerKeycloak.Components.Shared
```

You will also likely want to use cascading authentication state in your razor components.  

In .NET 7 and earlier, Change the project's `App.razor` to something like this:

```razor
<CascadingAuthenticationState>
    <Router AppAssembly="@typeof(Program).Assembly">
        <Found Context="routeData">
            <AuthorizeRouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)">
                <NotAuthorized>
                    <RedirectToSignin />
                    <h2>Authorization Required</h2>
                    <p>This page is restricted, please log in to the SSO with your credentials.</p>
                </NotAuthorized>
                <Authorizing>
                    <p>Authentication in progress.</p>
                </Authorizing>

            </AuthorizeRouteView> 
        </Found>

        <NotFound>
            <LayoutView Layout="@typeof(MainLayout)">
                <p>Sorry, there's nothing at this address.</p>
            </LayoutView>
        </NotFound>
    </Router>
</CascadingAuthenticationState>
```

In .NET 8+, place a call to `AddCascadingAuthenticationState` after the call to `AddKeycloak`:

```c#
builder.Services.AddKeycloak(builder.Configuration.GetRequiredSection("Oidc"));
// [..]
builder.Services.AddCascadingAuthenticationState();
```

### Login component

You will want to provide a mechanism for login somewhere.  The library comes with a component that will offer a sign-in or sign-out option based on the current authentication state.  An easy place to put it is in a typical project is in the `MainLayout.razor` component where the default template places the "About" link.  For example:

```razor
<div class="page">
    <div class="sidebar">
        <NavMenu />
    </div>

    <main>
        <div class="top-row px-4">
            <!-- Login component goes here, replacing the About link -->
            <Login />
        </div>

        <article class="content px-4">
            @Body
        </article>
    </main>
</div>
```

If the `Login` component is authenticated, it will display some text related to the user plus a "Sign Out" link.  If the component is not authenticated, it will display a "Sign In" link.

By default, the `Login` component will search for the `"preferred_username"` claim on the user and display that.  However, you can customize what text is displayed by adding a `IUserDisplayGetter` to the services collection.  For instance, if you want to use the `Identity.Name` property, you might create an implementation such as:

```c#
using BlazorServerKeycloak.Interfaces;

public class UserDisplayGetter : IUserDisplayGetter
{
    public Task<string?> Get(ClaimsPrincipal user)
    {
        return Task.FromResult(user.Identity?.Name);
    }
}
```

Or if you wanted to perform a lookup from a database or other system:

```c#
using BlazorServerKeycloak.Interfaces;

public class UserDisplayGetter : IUserDisplayGetter
{
    private readonly MyDbContext _db;

    public UserDisplayGetter(MyDbContext db) 
    {
        _db = db;
    }

    public async Task<string?> Get(ClaimsPrincipal user)
    {
        var user = await _db.Users.FirstOrDefault(u => u.Id == user.Claims.First(c => c.Type == "unique_id"));
        return user?.MySpecialName;
    }
}
```

In either case, register the getter with the service collection in `Program.cs`:

```c#
builder.Services.AddTransient<IUserDisplayGetter, UserDisplayGetter>();
```


At this point your application should successfully allow a user to sign in and sign out.

### User Realm Roles

Additional authorization policies can be added from Realm Roles mapped from Keycloak. If Keycloak is configured to map AD security groups to realm roles (see the example in [Mapping Realm Roles](#mapping-realm-roles)), these will be available in the ASP.NET context.  An authorization policy can be configured by setting up the following in `Program.cs`.

```c#
using BlazorServerKeycloak.Authorization;

// Role names come from the Realm Roles "Role Name" properties in Keycloak
var req = new UserRealmRoleRequirement("Role Name 1", "Role Name 2" /* 1 or more role names can be specified */);
// https://learn.microsoft.com/en-us/aspnet/core/diagnostics/asp0025
builder.Services.AddAuthorizationBuilder()
    .AddPolicy("MyPolicyName", policy => policy.Requirements.Add(req));

// ...

// Then make sure to register a handler to the services collection
builder.Services.AddTransient<IAuthorizationHandler, UserRealmRoleRequirementHandler>();
```

The requirement can be used in the typical ways:

```c#
// In a controller...
[Authorize(Policy = "MyPolicyName")]
public class SomeController : ControllerBase 
{
    // ...
}
```

```html
<!-- In a razor component to protect the entire thing -->
@attribute [Authorize(Policy = "MyPolicyName")]
```

```html
<!-- In a razor page Authorizeview -->
<AuthorizeView Policy="MyPolicyName">
    <!-- ... -->
</AuthorizeView>
```


### API Keys

A common requirement is to have API controllers which are protected by a key policy that works independently from a browser cookie based authentication/authorization mechanism. However, it's often convenient to be able to ignore the need for an API key if the request is coming from a browser with a valid session.

This library provides convenience mechanisms for implementing such a policy through the `ApiKeyRequirement` object, which works in conjunction with the `ApiKeyRequirementHandler`. The handler requires an `IApiKeySource` somewhere in the services collection, which you can implement yourself to look up keys from your own backend or use the pre-made `StaticApiKeySource` to work with a static list of keys like that which would come from the `appsettings.json` configuration file.

#### How It Works

A `UserRoleRequirement` can be embedded in the `ApiKeyRequirement` or left null.

The API key requirement handler will perform the following sequence of checks:

1. If no `UserRoleRequirement` is embedded in the key requirement, and the current context has an authenticated user, the handler will call `context.Succeed`
2. If a `UserRoleRequirement` is embedded in the key requirement and the current context has an authenticated user which has one of the allowed roles, the handler will call `context.Succeed`
3. If none of the previous were met but the header contains an `X-API-KEY` field with a value that, once SHA256 hashed and base-64 encoded, is verified by the `IApiKeySource`, the handler will call `context.Succeed`

#### Setting it up
```c#
using BlazorServerKeycloak.Authorization;

// Role names come from the Realm Roles "Role Name" properties in Keycloak
var req = new ApiKeyRequirement();
builder.Services.AddAuthorizationBuilder()
    .AddPolicy("MyApiKeyPolicy", policy => policy.Requirements.Add(req));

// ...

// Then make sure to register a handler to the services collection
builder.Services.AddTransient<IAuthorizationHandler, ApiKeyRequirementHandler>();

// Also make sure to put an IApiKeySource somewhere in your service collection!
// builder.Services.Add.......();
```

The requirement can then be applied to an API controller.

```c#
// In a controller...
[ApiController]
[Authorize(Policy = "MyApiKeyPolicy")]
public class SomeApiController : ControllerBase 
{
    // ...
}
```

#### The StaticApiKeySource

The `StaticApiKeySource` is a convenience class that provides a `IApiKeySource` from a dictionary in the `appsettings.json` file:

```json
"ApiKeys": {
    "User 1": "LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=",
    "User 2": "SG6kYiTRu0+2gPNPfJrZao8k7Ii+c+qOWmxlJg6cuKc="
}
```

*Warning: do not have identical hashes for different users.  These should be generated or kept unique in some way.*

The provider can be added to `Program.cs` with the following extension methods:

```c#
builder.Services.AddStaticApiKeys(builder.Configuration.GetSection("ApiKeys"));
```

For reference, here are examples of generating key hashes in Python and C#

```python
# Python
import hashlib, base64

def to_hash(text: str) -> str:
    return base64.b64encode(hashlib.sha256(text.encode("utf-8")).digest()).decode("utf-8")

print(to_hash("myapikeypassword"))
```

```c#
// C#
var text = "myapikeypassword";
var hashed = Convert.ToBase64String(SHA256.Create().ComputeHash(Encoding.UTF8.GetBytes(text)));
```

## Preparing Keycloak

These instructions assume you have a Keycloak instance up and running and you have administrator access to it.  Setting up Keycloak and federating it with Active Directory or LDAP is beyond the scope of this guide.

Preparing Keycloak to provide authentication and authorization to your application involves configuring a Keycloak *client*, in which the *client* is your application.

### Creating the client

In the desired Keycloak *realm* under the "Configure" menu, select "Clients".  You will be presented with a table of existing clients for realm.  Select the "Create" option to create a new client.

|Parameter|Value|
|-|-|
|Client ID| A human readable, URI safe text string which identifies the application.  For example, "test-app", or "example-application-name"|
|Client Protocol|Choose "openid-connect"|
|Root URL|You may leave this blank during development, but ultimately should point to the root URL for the application|

After setting the values, select "Save".

### Client configuration

After saving the new client you will be brought to the client editing page.  This can also be accessed by selecting "Edit" for a specific client from the table in the "Clients" page.  There are several tabs across the top, select the "Settings" tab.

Set the following parameters:

|Parameter|Value|
|-|-|
|Name|Typically I make this identical to the client ID, but it can also be a friendlier display name|
|Enabled|Set to "ON"|
|Access Type|Set to "confidential"|
|Standard Flow Enabled|Set to "ON"|
|Implicit FLow Enabled|Set to "ON"|
|Direct Access Grants Enabled|Set to "ON"|
|Valid Redirect URIs|See the detailed section below|
|Web Origins|I typically set this to "+" or "*"|

Be sure to save changes when done.

#### Valid Redirect URIs
These are URIs where Keycloak will allow redirection during the OIDC flow.  See the detailed section below.They must include the application OIDC endpoints or the process will not work.  For local development this will need to point at the localhost/port combination, for deployment it will need to point at the application's URI.  The endpoints `signin-odic` and `signout-oidc` will be required.

### Client Credentials

On the Client edit page, select the "Credentials" tab.  The client secret will be a hexadecimal text token in a grayed out box labeled "Secret".  This is the client secret that will be used in the configuration of the ASP.NET project.  

### Mapping User Attributes

If you want specific additional claims to be be added for a client, this can be done using a client mapper.

For example, imagine you have Keycloak federated with Active Directory and you want to pass along the unique ID associated with a user in LDAP.

Under the "Clients" nav menu item, select the client of interest from the table.  Next go to the "Mappers" tab.  Press the "Create" button.

| Parameter | Value |
|-------|----------|
| Name | Set a name for the mapping, for example `AD Unique ID` |
| Mapper Type | Select "User Attribute" |
| User Attribute | `LDAP_ID` |
| Token Claim Name | Set to the desired claim name, for example `unique_id` |
| Claim JSON Type | Select the type to be mapped, in this case we'll have to use a `String` |
| Add to ID token | ON |
| Add to access token | ON |
| Add to userinfo | ON |
| Multivalued | OFF |
| Aggregate attribute values | OFF |

Then press the "Save" button.

Now, when running the ASP.NET Core project, there will be an additional claim in the `ClaimsPrincipal.Claims` collection.  It will have the `Type` string property set to `"unique_id"`, and its `Value` property will be a string with the hexadecimal text representation of a `Guid`.  It can be retrieved like any other claim.

### Mapping Realm Roles

You can also map Keycloak realm roles to the ASP.NET Core `Claims` collection through the use of a client mapper.

Let's return to the example of using Keycloak federated with a local Active Directory instance.  Imagine that Keycloak is already mapping Active Directory security groups to Keycloak realm roles through the use of the `role-ldap-mapper` type.  This means that users in Keycloak show mappings to roles associated with the AD security groups they belong to.  You want to pass these security groups to the ASP.NET Core application.

Under the "Clients" nav menu item, select the client of interest from the table.  Next go to the "Mappers" tab.  Press the "Create" button.

| Parameter | Value |
|-------|----------|
| Name | Set a name for the mapping, for example `Realm Roles` |
| Mapper Type | Select "User Realm Role" |
| Realm Role prefix | (left blank, use if desired) |
| Multivalued | ON |
| Token Claim Name | Set to the desired claim name, for example `user_realm_roles` |
| Claim JSON Type | (left unselected) |
| Add to ID token | ON |
| Add to access token | ON |
| Add to userinfo | ON |

Now, when running the ASP.NET Core application, there will be multiple additional claims for each user.  Each of these claims will have the type of `"user_realm_roles"`, and the value will be a string with the name of one single AD security group mapped to that user.  There will be a unique claim for each group.

This particular mapping can be used directly with the `UserRealmRoleRequirement` policies included in the library and described in the [User Realm Roles](#user-realm-roles) section, or you can modify it and build your own.