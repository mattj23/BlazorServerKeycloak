# Blazor Server Keycloak Integration
Razor class library to add OIDC authentication to a Blazor server-side application

## Motivation

Blazor's server-side hosting model is extremely quick and convenient to develop with, and is more than adequate for internal line-of-business type applications which, by nature, have relatively few simultaneous users.  

Keycloak is an OpenIDConnect provider that is especially useful for internal applications because it can federate with LDAP (and Active Directory in particular) and effectively offer authentication against it through OIDC, even going so far as to map AD security groups as realm roles which are available as claims in the client application.

Nominally, the combination of server-side Blazor authenticated against Keycloak would be an ideal platform for rapidly developing and deploying internal business applications while hooking into existing centralized identity and access management tools common in small business infrastructure.  However, with the server-side hosting model the use of the SignalR hub and the lack of an `HttpContext` in established connections means that typical authentication schemes are not straightforward to implement.

This is a Razor class library which borrows heavily from https://github.com/vip32/aspnetcore-keycloak and packages all of the necessary components for authentication against Keycloak using OpenID Connect, including the configuration, the sign-in and sign-out endpoints, and an authorization requirement and handler to map to imported realm roles.

## Installation

The BlazorServerKeycloak library can be added to an ASP.NET 6 application either as a Nuget package or via git using the submodule mechanism.  The library was designed for and tested with server-side Blazor projects, I do not know if it will work with other types of ASP.NET projects, and I do not believe there is any reason to use it in such cases where a `HttpContext` is available for cookie based authentication.

### Nuget Package
Todo: Nuget package

### Git submodule

In your project, add this one as a git submodule:

```bash
git submodule add git@github.com:mattj23/BlazorServerKeycloak.git
```
In your solution file, add the existing project `BlazorServerKeycloak.csproj`.  Then in your Blazor server-side ASP.NET 6 project's dependencies add a project reference to `BlazorServerKeycloak`.

## Project Setup

To establish authentication via OIDC through Keycloak, you will need a Keycloak instance with a configured client for your application. If you do not have a client configured already and need help setting it up, refer to the [Preparing Keycloak](#preparing-keycloak) section below.


### Application Settings

You will need a section in your application configuration for the OIDC provider.

```json
"Oidc": {
    "Authority": "https://<keycloak url>/auth/realms/<realm name>",
    "ClientId": "<client id>",
    "ClientSecret": "<client secret>",
    "Resource": "<client id>",
    "Scope": [ "roles" ],
    "ResponseType": "code",
    "GetClaimsFromUserInfoEndpoint": false,
    "SaveTokens": true
}
```

Here the `Authority` is the URL of the Keycloak realm the application client was created under.  The `ClientId` is the id created for the client in Keycloak, and the `ClientSecret` is the token generated by Keycloak to match the client id.  Refer to the [Preparing Keycloak](#preparing-keycloak) section for more information.

### Program startup

In the new, simplified ASP.NET 6.0 setup's `Program.cs` file you will need to both add Keycloak integration to the `builder`'s service collection before the application is built and add authentication/authorization to the application.

```c#
var builder = WebApplication.CreateBuilder(args);

// Place this somewhere before the line `var app = builder.Build();`
builder.Services.AddKeycloak(builder.Configuration.GetSection("Oidc"));
```

```c#
// [...]
app.UseStaticFiles();
app.UseRouting();

// Insert UseAuthentication and UseAuthorization in this order
app.UseAuthentication();
app.UseAuthorization();

// [...]
app.MapBlazorHub();
app.MapFallbackToPage("/_Host");
app.Run();
```

### Imports and App.Razor

This library contains two razor components to help with the login process, located in the namespace `BlazorServerKeycloak.Shared`.  If you intend to use them you will need to add `@using` directives to any razor components which will reference them, or add them globally to the end of your project's `_Imports.razor` as shown:

```razor
@using BlazorServerKeycloak.Shared
```

You will also likely want to use cascading authentication state in your razor components.  I do this by changing the project's `App.razor` to something like this:

```razor
<Router AppAssembly="@typeof(Program).Assembly">
    <Found Context="routeData">
        <AuthorizeRouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)">
            <NotAuthorized>
                <RedirectToSignin />
                <h2>Authorization Required</h2>
                <p>This page is restricted, please log in to the SSO with your credentials.</p>
            </NotAuthorized>
            <Authorizing>
                <p>Authentication in progress.</p>
            </Authorizing>

        </AuthorizeRouteView> 
    </Found>

    <NotFound>
        <CascadingAuthenticationState>
            <LayoutView Layout="@typeof(MainLayout)">
                <p>Sorry, there's nothing at this address.</p>
            </LayoutView>
        </CascadingAuthenticationState>
    </NotFound>
</Router>
```

### Login component

You will want to provide a mechanism for login somewhere.  The library comes with a component that will offer a sign-in or sign-out option based on the current authentication state.  An easy place to put it is in a typical project is in the `MainLayout.razor` component where the default template places the "About" link.  For example:

```razor
<div class="page">
    <div class="sidebar">
        <NavMenu />
    </div>

    <main>
        <div class="top-row px-4">
            <!-- Login component goes here, replacing the About link -->
            <Login />
        </div>

        <article class="content px-4">
            @Body
        </article>
    </main>
</div>
```

At this point your application should successfully allow a user to sign in and sign out.

### User Realm Roles

Additional authorization policies can be added from Realm Roles mapped from Keycloak. If Keycloak is configured to map AD security groups to realm roles, these will be available in the ASP.NET context.  An authorization policy can be configured by setting up the following in `Program.cs`.

```c#
// Role names come from the Realm Roles "Role Name" properties in Keycloak
var req = new UserRealmRoleRequirement("Role Name 1", "Role Name 2" /* 1 or more role names can be specified */);
builder.Services.AddAuthorization(options =>
{
    // ... 
    options.AddPolicy("MyPolicyName", policy => policy.Requirements.Add(req));
    // ... 
});

// ...

// Then make sure to register a handler to the services collection
builder.Services.AddTransient<IAuthorizationHandler, UserRealmRoleRequirementHandler>();
```

The requirement can be used in the typical ways:

```c#
// In a controller...
[Authorize(Policy = "MyPolicyName")]
public class SomeController : ControllerBase 
{
    // ...
}
```

```html
<!-- In a razor component to protect the entire thing -->
@attribute [Authorize(Policy = "MyPolicyName")]
```

```html
<!-- In a razor page Authorizeview -->
<AuthorizeView Policy="MyPolicyName">
    <!-- ... -->
</AuthorizeView>
```


### API Keys

A common requirement is to have API controllers which are protected by a key policy that works independently from a browser cookie based authentication/authorization mechanism. However, it's often convenient to be able to ignore the need for an API key if the request is coming from a browser with a valid session.

This library provides convenience mechanisms for implementing such a policy through the `ApiKeyRequirement` object, which works in conjunction with the `ApiKeyRequirementHandler`. The handler requires an `IApiKeySource` somewhere in the services collection, which you can implement yourself to look up keys from your own backend or use the pre-made `StaticApiKeySource` to work with a static list of keys like that which would come from the `appsettings.json` configuration file.

#### How It Works

A `UserRoleRequirement` can be embedded in the `ApiKeyRequirement` or left null.

The API key requirement handler will perform the following sequence of checks:

1. If no `UserRoleRequirement` is embedded in the key requirement, and the current context has an authenticated user, the handler will call `context.Succeed`
2. If a `UserRoleRequirement` is embedded in the key requirement and the current context has an authenticated user which has one of the allowed roles, the handler will call `context.Succeed`
3. If none of the previous were met but the header contains an `X-API-KEY` field with a value that, once SHA256 hashed and base-64 encoded, is verified by the `IApiKeySource`, the handler will call `context.Succeed`

#### Setting it up
```c#
// Role names come from the Realm Roles "Role Name" properties in Keycloak
var req = new ApiKeyRequirement();
builder.Services.AddAuthorization(options =>
{
    // ... 
    options.AddPolicy("MyApiKeyPolicy", policy => policy.Requirements.Add(req));
    // ... 
});

// ...

// Then make sure to register a handler to the services collection
builder.Services.AddTransient<IAuthorizationHandler, ApiKeyRequirementHandler>();

// Also make sure to put an IApiKeySource somewhere in your service collection!
// builder.Services.Add.......();
```

The requirement can then be applied to an API controller.

```c#
// In a controller...
[ApiController]
[Authorize(Policy = "MyApiKeyPolicy")]
public class SomeApiController : ControllerBase 
{
    // ...
}
```

#### The StaticApiKeySource

The `StaticApiKeySource` is a convenience class that provides a `IApiKeySource` from a dictionary in the `appsettings.json` file:

```json
"ApiKeys": {
    "User 1": "LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=",
    "User 2": "SG6kYiTRu0+2gPNPfJrZao8k7Ii+c+qOWmxlJg6cuKc="
}
```

*Warning: do not have identical hashes for different users.  These should be generated or kept unique in some way.*

The provider can be added to `Program.cs` with the following extension methods:

```c#
builder.Services.AddStaticApiKeys(builder.Configuration.GetSection("ApiKeys"));
```

For reference, here are examples of generating key hashes in Python and C#

```python
# Python
import hashlib, base64

def to_hash(text: str) -> str:
    return base64.b64encode(hashlib.sha256(text.encode("utf-8")).digest()).decode("utf-8")

print(to_hash("myapikeypassword"))
```

```c#
// C#
var text = "myapikeypassword";
var hashed = Convert.ToBase64String(SHA256.Create().ComputeHash(Encoding.UTF8.GetBytes(text)));
```

## Preparing Keycloak

These instructions assume you have a Keycloak instance up and running and you have administrator access to it.  Setting up Keycloak and federating it with Active Directory or LDAP is beyond the scope of this guide.

Preparing Keycloak to provide authentication and authorization to your application involves configuring a Keycloak *client*, in which the *client* is your application.

### Creating the client

In the desired Keycloak *realm* under the "Configure" menu, select "Clients".  You will be presented with a table of existing clients for realm.  Select the "Create" option to create a new client.

|Parameter|Value|
|-|-|
|Client ID| A human readable, URI safe text string which identifies the application.  For example, "test-app", or "example-application-name"|
|Client Protocol|Choose "openid-connect"|
|Root URL|You may leave this blank during development, but ultimately should point to the root URL for the application|

After setting the values, select "Save".

### Client configuration

After saving the new client you will be brought to the client editing page.  This can also be accessed by selecting "Edit" for a specific client from the table in the "Clients" page.  There are several tabs across the top, select the "Settings" tab.

Set the following parameters:

|Parameter|Value|
|-|-|
|Name|Typically I make this identical to the client ID, but it can also be a friendlier display name|
|Enabled|Set to "ON"|
|Access Type|Set to "confidential"|
|Standard Flow Enabled|Set to "ON"|
|Implicit FLow Enabled|Set to "ON"|
|Direct Access Grants Enabled|Set to "ON"|
|Valid Redirect URIs|See the detailed section below|
|Web Origins|I typically set this to "+" or "*"|

Be sure to save changes when done.

#### Valid Redirect URIs
These are URIs where Keycloak will allow redirection during the OIDC flow.  See the detailed section below.They must include the application OIDC endpoints or the process will not work.  For local development this will need to point at the localhost/port combination, for deployment it will need to point at the application's URI.  The endpoints `signin-odic` and `signout-oidc` will be required.

### Client Credentials

On the Client edit page, select the "Credentials" tab.  The client secret will be a hexadecimal text token in a grayed out box labeled "Secret".  This is the client secret that will be used in the configuration of the ASP.NET project.  

